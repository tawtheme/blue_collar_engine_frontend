{"ast":null,"code":"import { HttpRequest, HttpResponse, HttpHandler, HttpEvent, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '@app/_models';\nimport * as i0 from \"@angular/core\";\nconst users = [{\n  id: 1,\n  username: 'admin',\n  password: 'admin',\n  firstName: 'Admin',\n  lastName: 'User',\n  role: Role.Admin\n}, {\n  id: 2,\n  username: 'user',\n  password: 'user',\n  firstName: 'Normal',\n  lastName: 'User',\n  role: Role.User\n}];\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      return handleRoute();\n\n      function handleRoute() {\n        switch (true) {\n          case url.endsWith('/users/authenticate') && method === 'POST':\n            return authenticate();\n\n          case url.endsWith('/users') && method === 'GET':\n            return getUsers();\n\n          case url.match(/\\/users\\/\\d+$/) && method === 'GET':\n            return getUserById();\n\n          default:\n            // pass through any requests not handled above\n            return next.handle(request);\n        }\n      } // route functions\n\n\n      function authenticate() {\n        const {\n          username,\n          password\n        } = body;\n        const user = users.find(x => x.username === username && x.password === password);\n        if (!user) return error('Username or password is incorrect');\n        return ok({\n          id: user.id,\n          username: user.username,\n          firstName: user.firstName,\n          lastName: user.lastName,\n          role: user.role,\n          token: `fake-jwt-token.${user.id}`\n        });\n      }\n\n      function getUsers() {\n        if (!isAdmin()) return unauthorized();\n        return ok(users);\n      }\n\n      function getUserById() {\n        if (!isLoggedIn()) return unauthorized(); // only admins can access other user records\n\n        if (!isAdmin() && currentUser()?.id !== idFromUrl()) return unauthorized();\n        const user = users.find(x => x.id === idFromUrl());\n        return ok(user);\n      } // helper functions\n\n\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        })).pipe(delay(500)); // delay observable to simulate server api call\n      }\n\n      function unauthorized() {\n        return throwError(() => ({\n          status: 401,\n          error: {\n            message: 'unauthorized'\n          }\n        })).pipe(materialize(), delay(500), dematerialize()); // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648);\n      }\n\n      function error(message) {\n        return throwError(() => ({\n          status: 400,\n          error: {\n            message\n          }\n        })).pipe(materialize(), delay(500), dematerialize());\n      }\n\n      function isLoggedIn() {\n        const authHeader = headers.get('Authorization') || '';\n        return authHeader.startsWith('Bearer fake-jwt-token');\n      }\n\n      function isAdmin() {\n        return currentUser()?.role === Role.Admin;\n      }\n\n      function currentUser() {\n        if (!isLoggedIn()) return;\n        const id = parseInt(headers.get('Authorization').split('.')[1]);\n        return users.find(x => x.id === id);\n      }\n\n      function idFromUrl() {\n        const urlParts = url.split('/');\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n    }\n\n  }\n\n  FakeBackendInterceptor.ɵfac = function FakeBackendInterceptor_Factory(t) {\n    return new (t || FakeBackendInterceptor)();\n  };\n\n  FakeBackendInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor,\n    factory: FakeBackendInterceptor.ɵfac\n  });\n  return FakeBackendInterceptor;\n})();\nexport const fakeBackendProvider = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module"}